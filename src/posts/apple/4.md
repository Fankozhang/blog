<!--

 * @name: 东方凝洛
 * @Date: 2022-12-02 21:19:19
 * @msg: 
 * @param: 
 * @return: 
-->
---
<!-- icon: edit -->
date: 2022-12-03
category:

  - 前端知识
  - vue
tag:
  - vue
  - javascript
---

# vue

## vue项目打包一键去掉所有console.log

在Vue项目中，可以通过使用babel插件来去除所有的console.log语句。以下是一种常用的方法：

1. 安装babel插件：babel-plugin-transform-remove-console

```
npm install babel-plugin-transform-remove-console --save-dev
```

1. 在项目的根目录下创建一个babel.config.js文件，并添加以下内容：

```
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    process.env.NODE_ENV === 'production' ? 'transform-remove-console' : ''
  ]
}
```

1. 运行打包命令，例如：

```
npm run build
```

这样，在生产环境下，所有的console.log语句都会被自动去除。

请注意，这只会在打包时去除console.log语句，而不会影响开发环境下的调试信息。

你可以参考以下链接获取更多关于此话题的信息：

- [Vue CLI官方文档 - Babel配置](https://cli.vuejs.org/zh/guide/browser-compatibility.html#babel)
- [babel-plugin-transform-remove-console](https://www.npmjs.com/package/babel-plugin-transform-remove-console)

继续聊天

## 相关搜索

## element  ui按需导入

 `cnpm install element-ui --save-dev` 

main.js

```
import {
    Button,
    Popover,
    Cascader,
    CascaderPanel
} from 'element-ui'

Vue.use(Button)
Vue.use(Popover)
Vue.use(Cascader)
Vue.use(CascaderPanel)
```

在使用组件的页面导入样式

```
import 'element-ui/lib/theme-chalk/index.css'
```



## vue实现登录后跳转到之前的页面

 [(202条消息) vue实现登录后跳转到之前的页面_longzhoufeng的博客-CSDN博客](https://blog.csdn.net/longzhoufeng/article/details/106646698) 

main.js

```
router.beforeEach((to, from, next) => {
    if (to.path == '/login' && from.path!='/register') {
    	//保存当前路由
        localStorage.setItem("preRoute", router.currentRoute.fullPath)
    }
    next()
})
```

 登录界面 login.vue 

```
this.$store.dispatch("Login", this.loginForm).then(response => {
	if (response.code == 200) {
		const curr = localStorage.getItem('preRoute')
		if (curr == null) {
			this.$router.push({ path: "/user_center" });
		} else {
			this.$router.push({ path: curr });
		}
		this.$message({ message: response.msg, type: "success", "duration": 1000 });
	} else {
		this.$message.error(response.msg);
	}
}).catch((response) => {
	this.$message.error('请联系管理员！！！');
});
```



## vue2和vue3响应式（简易版）

vue2通过遍历循环对象属性（for key in obj），在对每一个属性的值用 Object.defineProperty 进行getter和setter的改造 

vue3通过Proxy（代理）和Reflect（反射）的使用完成 响应式。

```js
function observe(data){
  if(!data || typeof data !== 'object') return
  for(let key in data){
    let value = data[key]
    Object.defineProperty(data, key, {
      enumerable: true,
      configurable: true,
      get(){
        return value
      },
      set(newVal){
        value = newVal
      }
    })
    if(typeof value === 'object'){
      observe(value)
    }
  }
}
```

```js
function reactive(obj){
  const handler = {
    get(target, key, receiver){
      const value = Reflect.get(...arguments)
      if(typeof value === 'object'){
        return reactive(value)
      }else{
        return value
      }
    },
    set(target, key, val, receiver){
      return Reflect.set(...arguments)
    }
  }
  
  return new Proxy(obj, handler)
}
```



### vuex的基本使用   pinia的基本使用

vuex的基本使用可以查看以下文章：

https://juejin.cn/post/6928468842377117709

https://juejin.cn/post/6994337441314242590#heading-15

https://juejin.cn/post/7087100496762109983#heading-16

pinia的基本使用可以查看以下文章：  (pinia相比vuex简单很多)

https://juejin.cn/post/7078281612013764616#heading-0

## vue实现全屏滚动

页面全屏滚动很多用于官网首页，使用的频率还挺高的，此处的代码实现的功能是 鼠标滚动，页面切换，点击键盘的上下键，页面切换。类似效果看  [ 全屏滚动_jQuery之家-自由分享jQuery、html5、css3的插件库 (htmleaf.com)](http://www.htmleaf.com/plus/search.php) ，以下内容改自 [vue实现全屏滚动，非fullpage.js-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/835013) 。

.vue文件

 @mousewheel.prevent   鼠标滚动，实现页面的切换

@keyup.prevent   点击键盘实现页面滚动，此处为键盘上下键点击实现页面滚动

```html
<div class="fullPage" ref="fullPage">
	<div
    class="fullPageContainer"
    ref="fullPageContainer"
    @mousewheel.prevent="mouseWheelHandle"
    @keyup.prevent="keyHandle"
    @DOMMouseScroll.prevent="mouseWheelHandle" >
    	<div style="width:100%;height:100vh;overflow: hidden;">
            <div>
            	// 这个div写页面里面的内容，页面的内容占满一整个屏幕
            </div>
        </div>
        <div style="width:100%;height:100vh;overflow: hidden;"></div>
        <div style="width:100%;height:100vh;overflow: hidden;"></div>
		<div style="width:100%;height:100vh;overflow: hidden;"></div>
		........
        //  有几个全屏滚动的页面，就写几个div
    </div>
</div>
```

css

```css
<style lang="less" scoped>
.fullPage{
  height: 100%;//一定要设置，保证占满
  overflow: hidden;//一定要设置，多余的先隐藏
}
.fullPageContainer{
  width: 100%;
  height: 100%;
  transition: all linear 0.5s;
}
</style>
```

script

```javascript
mounted(){
    //  没有在mounted里加上键盘点击事件，使用键盘点击切换页面会出bug。即点击完页面时能使用键盘实现页面滚动，当点击了网页外在点击回网页内，键盘上下键切换页面会失效。
	window.addEventListener('keyup', this.keyHandle, false)
},

methods:{
   next () { // 往下切换
      const len = 4 // 页面的个数
      if (this.fullpage.current + 1 <= len) { // 如果当前页面编号+1 小于总个数，则可以执行向下滑动
        this.fullpage.current += 1 // 页面+1
        this.move(this.fullpage.current) // 执行切换
      }
    },
    pre () { // 往上切换
      if (this.fullpage.current - 1 > 0) { // 如果当前页面编号-1 大于0，则可以执行向下滑动
        this.fullpage.current -= 1// 页面+1
        this.move(this.fullpage.current)// 执行切换
      }
    },
    move (index) {
      this.fullpage.isScrolling = true // 为了防止滚动多页，需要通过一个变量来控制是否滚动
      this.directToMove(index) // 执行滚动
      setTimeout(() => { // 这里的动画是1s执行完，使用setTimeout延迟1s后解锁
        this.fullpage.isScrolling = false
      }, 500)
    },
    directToMove (index) {
      const height = document.body.clientHeight
      // const height = this.$refs['fullPage'].clientHeight // 获取屏幕的宽度
      const scrollPage = this.$refs['fullPageContainer'] // 获取执行tarnsform的元素
      let scrollHeight = '' // 计算滚动的告诉，是往上滚还往下滚
      scrollHeight = -(index - 1) * height + 'px'
      scrollPage.style.transform = `translateY(${scrollHeight})`
      this.fullpage.current = index
    },
    mouseWheelHandle (event) { // 监听鼠标监听
      // 添加冒泡阻止
      const evt = event || window.event
      if (evt.stopPropagation) {
        evt.stopPropagation()
      } else {
        evt.returnValue = false
      }
      if (this.fullpage.isScrolling) { // 判断是否可以滚动
        return false
      }
      const e = event.originalEvent || event
      this.fullpage.deltaY = e.deltaY || e.detail // Firefox使用detail
      if (this.fullpage.deltaY > 0) {
        this.next()
      } else if (this.fullpage.deltaY < 0) {
        this.pre()
      }
    },
    keyHandle (event) {
      const evt = event || window.event
      if (evt.keyCode === 40) { // 下滑
        this.next()
      }
      if (evt.keyCode === 38) {
        this.pre()
      }
    },
}
```

## vue项目跳转时如何加密路由上面query传递的参数

 [vue-router路由中对query中的参数进行加密_router 参数加密_前端_小学生的博客-CSDN博客](https://blog.csdn.net/weixin_44243061/article/details/107092308) 

 [vue-router中传递的参数进行自动加密显示，组件中获取自动解密 (github.com)](https://github.com/wukang0718/vueRouterEncryption) 

(实际使用有bug,在新页面打开带参数的url时，加密的参数并不能够解析出来)

## 后端返回很大的数据量，前端如何渲染

https://mp.weixin.qq.com/s/pWsntJbJnBip5CbP7HkvFg

## vite创建vue3项目

普通创建vite项目

```
npm init vite@latest
```

模板创建项目

```
npm init vite@latest myproject -- --template vue
```

如果使用普通创建的方式，依次选择需要的配置项即可，如果模板创建，即可直接下载依赖运行

#### 配置路由：

```
npm install vue-router
```

src目录下创建roter文件夹，文件夹下创建 index.js

src目录下创建views文件夹，用于存放页面。此处创建about.vue和list.vue用于测试

router/index.js内容如下：

```vue
import {
    createRouter,
    createWebHashHistory
} from 'vue-router'

const router = createRouter({
    history: createWebHashHistory(),
    // createWebHashHistory 用来配置内部使用hash模式路由
    routes: [{
            path: '/',
            redirect: '/about'
        },
        {
            path: '/about',
            name: 'about',
            component: () =>
                import ('../views/about.vue')
        },
        {
            path: '/list',
            name: 'list',
            component: () =>
                import ('../views/list.vue')
        },
    ]
})

export default router
```

在main.js引入路由文件并使用

```vue
import { createApp } from 'vue'
import './style.css'    // 对于原始样式不需要可以注释掉
import App from './App.vue'
import router from './router/index'

createApp(App).use(router).mount('#app') 
```

app.vue中只留下

```
<template>
  <router-view></router-view>
</template>
```

在使用路由的页面中使用函数式路由跳转

```vue
<template>
	<div>
		{{$route.query}}   //界面中可以通过 $route.query 来获取参数
	</div>
</template>

<script setup lang="ts">
import { useRoute,useRouter } from "vue-router";
const router=useRouter()
const route=useRoute()

const go=()=>{
   router.push({path:'/list',query:{name:'张三'}})
}

onMounted(()=>{
    console.log("route",route.query)
}

</script>
```

至此，路由配置完成。

**注意：vue3中引入的组件可以直接使用**

#### vite.config.js 配置  server服务  @ 路径

```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import {
    resolve
} from "path"

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [vue()],
    server: {
        // 启动后打开浏览器
        open: true,
        // 设置主机
        host: '127.0.0.1',
        // 设置端口
        port: 3001
    },
    resolve: {
        // ↓路径别名，主要是这部分
        alias: {
            "@": resolve(__dirname, "./src")
        }
    }
})
```

#### 下载less依赖

```

npm i less-loader less style-resources-loader --save-dev
```

#### 下载配置  element-plus

```
npm install element-plus --save
```

main.js

```
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

createApp(App).use(router).use(ElementPlus).mount('#app')
```





## Vue3 中引入wangeditor富文本编辑器

```
npm i wangeditor -S
```

在需要用到的页面引入

```
//这里名字无所谓, 就是待会new的时候要用这个名字new
import EWangEditor from "wangeditor";
```

在页面内使用

```vue
<script setup lang="ts">
import { ref ,reactive} from '@vue/reactivity'
import EWangEditor from "wangeditor";
import { onMounted } from '@vue/runtime-core';

let data=reactive({})

onMounted(()=>{
  console.log("onMounted",a,b,c)
  //这里的"#editor"对应要渲染为编辑器的html元素的id, 就像以前的querySelector()
  let editor=new EWangEditor("#editor")
  editor.config.uploadImgShowBase64 = true;
  // 你在wangeditor内写入的字符会被wangeditor自动转为HTML, 我们设定的更新频率, 即它每隔多久将你的文字提取并转换为HTML一次.
  /* 配置检测字符变化的最短时间间隔，默认为 200ms */
  editor.config.onchangeTimeout=400
  //如果检测到错误的话就打印.
  editor.config.customAlert=(err)=>{
    console.log(err)
  }
  editor.customConfig=editor.customConfig ? editor.customConfig : editor.config
  //设置customConfig属性
  //设置customConfig对编辑器内文字的变化的处理方法
  editor.customConfig.onchange = (html) => {  //参数html即已经转化HTML格式的文本
  data.editorContent = html;
  //在data中提前声明editorContent来存储
  console.log(html);  //实时输出更新的html格式
  };

   //以下为新增
  const menuItem = [  //工具栏里有哪些工具
    "head",
    "bold",
    "fontSize",
    "fontName",
    "italic",
    "underline",
    "indent",
    "lineHeight",
    "foreColor",
    "backColor",
    "link",
    "list",
    "justify",
    "image",
    "video",
  ];

editor.config.menus = [...menuItem]; /* 应用设置好的工具栏 */
     
editor.config.colors = ["#000000", "#eeece0", "#1c487f", "#4d80bf","#fff0f0","#20a8ff"];  /* 文字颜色、背景色可以选择哪些颜色? */
      
editor.config.fontNames = [ /* 字体工具提供哪些字体? */ 
  "黑体",
  "仿宋",
  "楷体",
  "标楷体",
  "华文仿宋",
  "华文楷体",
  "宋体",
  "微软雅黑",
];

editor.config.height = 500;  //你可能发现这个编辑器是没法用样式调高度的?
//新增至此
  editor.create()
})
</script>

<template>
  <div>
    <!-- id要为new wangeditor对象时候使用的id -->
    <div id="editor" name="editor" ref="editor" style="height:100px"></div>
  </div>
</template>

<style scoped>

</style>

```

## vue中引入二维码（ vue-qr ）

```
// npm
npm install vue-qr --save
```

```js
//  页面引入组件
// vue2.x 
import VueQr from 'vue-qr'
// vue3.x 
import vueQr from 'vue-qr/src/packages/vue-qr.vue'

```

```
<vue-qr  
         id="vueQrs"   
         :text="textValue"
         :logoSrc="logoPath"
         :logoScale="40" 
         :size="190" 
         :margin="10"
         @click="downloadQR"
     />  
```

| text      | 二维码要展示的内容                                           |
| --------- | ------------------------------------------------------------ |
| logoSrc   | 二维码中间的小logo                                           |
| logoScale | 小logo的大小（别搞太大，超过容错率识别不出来的）             |
| size      | 整个二维码所占空间的大小，（宽高相等，包含margin） 可能需要你自己用css设置一下图片宽高100% |
| margin    | 二维码的外边距（默认 20px）                                  |

```
// 事件处理函数(下载二维码)
	const downloadQR=()=> {
            const a = document.createElement('a')
            // 下载的文件名
            a.download = '二维码'
            // url
            let loadElement=document.getElementById("vueQrs")
            a.href = loadElement.src
            // 触发点击
            a.click()
        }
```



## vue3中 setup语法糖使用组件级的路由导航守卫，定义组件name (unplugin-vue-define-options)

 [unplugin-vue-macros(github.com)  ](https://github.com/sxzz/unplugin-vue-macros/blob/HEAD/packages/define-options/README-zh-CN.md) 

>  在 `<script setup >` 中可使用 defineOptions 宏，以便在 `<script setup >` 中使用 Options API。 尤其是能够在一个函数中设置 name、props、emit 和 render 属性。 有了这个宏，你就可以在 `<script setup>` 使用 Options API； 

```
 npm i unplugin-vue-define-options -D 
```

 vite.config.ts 

```vue
import DefineOptions from 'unplugin-vue-define-options/vite'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [vue(), DefineOptions()],
    resolve: {
        // ↓路径别名，主要是这部分
        alias: {
            "@": resolve(__dirname, "./src")
        }
    }
})
```

在需要的组件页面加入代码：

```vue
<script setup lang="ts">

defineOptions({
  name: '***',     // name可用于配置组件 名称
  beforeRouteEnter(to, from, next) {
    next((vm) => {
      console.log(vm,to,from,'123456')
    })
  }
})

</script>
```

## vue 搭建组件库（简易）

 [b站参考学习视频地址](https://www.bilibili.com/video/BV1Zf4y1u75o?p=1&vd_source=f25f5a8d75a3a60d5a288f726803ec11)    [参考文章  vue组件库的基本开发步骤 ](https://www.cnblogs.com/luoluo-snow/p/11636943.html) 

一开始跟着视频编写代码，但是到了webpack打包，webpack.component.js文件和依赖引入时出现了挺多的报错（尝试了几个解决方法，最终没能解决，在打包完css后直接发布了），在打包发布到了npm网站后引入组件，打开页面控制台报红，果然失败了。

后来参考文章，用脚手架自带的打包，成功部署到npm网站上了。使用正常。

vue组件库制作：npm初始化项目+编写组件+webpack打包js+gulp打包css+npm发布 

### 搭建vue项目和运行环境（示例）

1、首先，创建一个普通的vue2项目

2、打开项目，将src目录下的components文件夹放到项目根目录下，改名为packages,将src文件名改为examples。此时运行项目会报错。原因是vue寻找文件默认是从src目录下寻找，我们改了src名为examples，所以需要对配置进行修改。

修改方法：创建vue.config,js文件，代码如下

```
module.exports = {
    pages: {
        index: {
            entry: 'examples/main.js',
            template: 'examples/index.html',
            filename: 'index.html'
        }
    }
    
     // 扩展 webpack 配置，使 examples 加入编译
    chainWebpack: config => {
        config.module
            .rule('js')
            .include
            .add('/examples')
            .end()
            .use('babel')
            .loader('babel-loader')
    }
}
```

修改配置文件后，重启项目，成功运行。

3、css文件夹下编写css样式，（如用到scss则需要引入依赖，注意版本问题）

创建vue组件文件  (packages/lib/demo/src/main.vue)

创建index.js（packages/lib/demo/index.js) ，这个js文件用于编写注册组件的代码，最终引入到main.js  

如创建Demo组件，index.js代码如下：

```
import Demo from '../demo/src/main.vue'

Demo.install = function(Vue) {
    Vue.component(Demo.name, Demo)
}

export default Demo
```

最终在main.js引入css文件和组件注册的js代码，(此处的demo.scss属于全局引入了，在组件内可以直接使用的)

```
import Vue from 'vue'
import App from './App.vue'
import '../packages/css/demo.scss'
import Demo from "../packages/lib/demo/index"

Vue.config.productionTip = false
Vue.use(Demo)

new Vue({
    render: h => h(App),
}).$mount('#app')
```

当配置完成后，项目可正常运行。

### 组件制作

1、组件设计（通用性）

2、编写html和css样式

3、编写组件逻辑代码

4、测试组件

（card组件示例代码如下）

```
<template>
  <div class="f-card">
     <div class="f-card-img" :style="width?{width:width+'px'}:{}">
        <img :src="imgSrc" alt="img" :style="imgHeight?{height:imgHeight+'px'}:{}"/>
     </div>
     <div v-if="summary" class="f-card-summary">
        {{summary}}
     </div>
      <div v-else class="f-card-summary">
        <slot></slot>
     </div>
     <!-- <div class="f-card-footer">
        footer
     </div> -->
     <slot name="footer"></slot>
  </div>
</template>

<script>
export default {
    name:'Card',
    props:{
        width:{       //卡片宽度
            type:Number,
            default:0
        },
        imgSrc:{       //图片资源地址
            type:String,
            default:''
        },
        imgHeight:{    //图片高度
            type:Number,
            default:0
        },
        summary:{    //概述
            type:String,
            default:''
        }
    },
  data() {
    return {

    }
  },
  methods: {

  },
  created() {

  },
}
</script>
<style scoped>

</style>
```

```
.f-card {
    width: 270px;
    border-radius: 8px;
    background: white;
    overflow: hidden;
    padding-bottom: 8px;
    box-shadow: 10px 5px 5px #efefef;
    &-img {
        height: 152px;
        img {
            width: 100%;
            height: 100%
        }
    }
    &-summary {
        padding: 8px;
        font-size: 14px;
        text-align: left;
    }
    &-footer {}
}
```

测试的组件代码如下，运行功能正常

```
<template>
  <div id="app">
    <img alt="Vue logo" src="./assets/logo.png">
    <demo></demo>
    <Card 
      imgSrc="123456.png"
      summary="这是一个card组件"
      width='570'
      imgHeight="130"
    >
     123
      <template v-slot:footer>
        footer
      </template>
  </Card>
  </div>
</template>
```

### 打包

在写组件的文件夹 同级目录创建index.js文件，用于汇总导出所有组件，便于打包后引用

```
import Demo from './demo'
import Card from "./card"

const components = {
    Demo,
    Card
}

const install = function(Vue) {
    if (install.installed) return;
    Object.keys(components).forEach(key => {
        Vue.component(components[key].name, components[key])
    })
}

export default {
    install,
    Card,
    Demo
}
```

css也是同级创建index.css，引入其他的css文件，便于打包后引用

```
@import url('./demo.scss');
@import url('./card.scss');
```

创建打包命令行，并执行

webpack打包js为umd模块

```
"scripts": {        
        "serve": "vue-cli-service serve",
        "build": "vue-cli-service build",
        "lint": "vue-cli-service lint",
        "build:lib": "vue-cli-service build --target lib --name dfk --dest lib packages/lib/index.js",
        "build:css": "npx gulp sass"
    },
```

```
运行  npm run build:lib 打包js代码，注意文件路径报错
```



创建gulpfile.js文件，用于打包css文件，使用的scss（下载下方需要的4个依赖，注意自己的文件路径）

```
const gulp = require('gulp');
// const sass = require('gulp-sass');
const sass = require('gulp-sass')(require('sass'));
const minifyCSS = require('gulp-minify-css');

gulp.task('sass', async function() {
    return gulp.src('packages/**/*.scss')
        .pipe(sass())
        .pipe(minifyCSS())
        .pipe(gulp.dest('lib/css'))
})
```

运行  npm run build:css 打包css代码，注意文件路径报错

### 发布

1、准备一个npm账号

2、npm login  登录npm账号

3、npm publish (推送代码，注意修改package.json的配置)

```
    "name": "fankoui3",
    "version": "0.1.0",
    "description": "npm测试",            //描述
    "main": "lib/dfk.umd.js",           //打包文件入口
    "keywords": [                       //关键字
        "f-ui",
        "vue",
        "ui"
    ],
    "author": "fanko",   //作者
    "files": [          //要打包的文件路径
        "lib",
        "packages"
    ],
    "scripts": {        
        "serve": "vue-cli-service serve",
        "build": "vue-cli-service build",
        "lint": "vue-cli-service lint",
        "build:lib": "vue-cli-service build --target lib --name dfk --dest lib packages/lib/index.js",
        "build:css": "npx gulp sass"
    },
```

发布成功后从npm网站账号内可看到

### 测试

创建一个vue项目

下载 fankoui3 依赖

main.js (引入依赖和css样式并使用)

```
import Vue from 'vue'
import App from './App.vue'

import "fankoui3/lib/css/css/index.css"
import fankoui3 from "fankoui3"
Vue.config.productionTip = false

Vue.use(fankoui3)
new Vue({
    render: h => h(App),
}).$mount('#app')
```

在vue文件中使用Card组件，如可显示正常，则组件库创建成功。



## vue项目截取网页的dom元素，生成pdf文档并下载

npm install html2canvas         npm install  jspdf

```vue
<template>
  <div id="about" ref="about"  @click="exportPDF">
    <h1>This is an about page</h1>
    <div  class="box">
      welcom to about </div>
  </div>
</template>
<script>
import html2canvas from 'html2canvas';
import { jsPDF } from "jspdf";
export default {
  data() {
  },
  methods: {
    exportPDF() {
      // 导出pdf
      this.scale = 1;
      this.$nextTick(() => {
        // let shareContent = document.body,//需要截图的包裹的（原生的）DOM 对象
        const shareContent = document.getElementById("about");
        // width = shareContent.clientWidth, //获取dom 宽度
        // height = shareContent.clientHeight, //获取dom 高度
        const width = shareContent.offsetWidth; // 获取dom 宽度
        const height = shareContent.offsetHeight; // 获取dom 高度
        const canvas = document.createElement("canvas"); // 创建一个canvas节点
        const scale = 1 / this.scale; // 定义任意放大倍数 支持小数
        canvas.width = width * scale; // 定义canvas 宽度 * 缩放
        canvas.height = height * scale; // 定义canvas高度 *缩放
        canvas.style.width = shareContent.clientWidth * scale + "px";
        canvas.style.height = shareContent.clientHeight * scale + "px";
        canvas.getContext("2d").scale(scale, scale); // 获取context,设置scale
        const opts = {
          scale: scale, // 添加的scale 参数
          canvas: canvas, // 自定义 canvas
          logging: false, // 日志开关，便于查看html2canvas的内部执行流程
          width: width, // dom 原始宽度
          height: height,
          useCORS: true, // 【重要】开启跨域配置
        };
        html2canvas(shareContent, opts).then(() => {
          var contentWidth = canvas.width;
          var contentHeight = canvas.height;
          // 一页pdf显示html页面生成的canvas高度;
          // var pageHeight = (contentWidth / 592.28) * 841.89;
          var pageHeight = (contentWidth / 592.28) * 841.89;
          // 未生成pdf的html页面高度
          var leftHeight = contentHeight;
          // 页面偏移
          var position = 0;
          // a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高
          var imgWidth = 595.28;
          var imgHeight = (592.28 / contentWidth) * contentHeight;
          var pageData = canvas.toDataURL("image/jpeg", 1.0);
          var PDF = new jsPDF("", "pt", "a4");
          if (leftHeight < pageHeight) {
            PDF.addImage(pageData, "JPEG", 0, 0, imgWidth, imgHeight);
          } else {
            while (leftHeight > 0) {
              PDF.addImage(pageData, "JPEG", 0, position, imgWidth, imgHeight);
              leftHeight -= pageHeight;
              position -= 841.89;
              if (leftHeight > 0) {
                PDF.addPage();
              }
            }
          }
          // name = this.basicInfo.name;
          PDF.save('导出的pdf文件名' + ".pdf"); // 这里是导出的文件名
          this.scale = window.innerHeight / 1200;
        });
      });
    },

  },
  created() {

  },
}
</script>
<style scoped>
#about{
  width:50%;
  margin:auto;
}
.box{
  width:200px;height:30px;font-size:20px;font-weight:bold;
  background:linear-gradient(to right,#289a47,#e74032);
}
</style>
```

## vue3基本使用（用setup 语法糖）

### 计算属性

```
import { ref,reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 一个计算属性 ref，随后访问publishedBooksMessage的值要用 publishedBooksMessage.value
const publishedBooksMessage = computed(() => {
  return author.books.length 
})


// 计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用  到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建
const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
```

### watch

```
const x = ref(0)
const y = ref(0)

// 单个 ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// getter 函数
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)

// 多个来源组成的数组
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})


//不能直接侦听响应式对象的属性值,这里需要用一个返回该属性的 getter 函数
// 提供一个 getter 函数
watch(
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  },
  //  { deep: true }  深度监听
  //  { immediate: true }   //立即执行
) 
```

### `watchEffect()`

 侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 `todoId` 的引用发生变化时使用侦听器来加载一个远程资源 

```
const todoId = ref(1)
const data = ref(null)

watch(todoId, async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
}, { immediate: true })
```

 特别是注意侦听器是如何两次使用 `todoId` 的，一次是作为源，另一次是在回调中。 

 用 [`watchEffect` 函数](https://cn.vuejs.org/api/reactivity-core.html#watcheffect) 来简化上面的代码。`watchEffect()` 允许我们自动跟踪回调的响应式依赖 

```
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
```

停止侦听器

```
// 它会自动停止
watchEffect(() => {})


// 手动停止
const unwatch = watchEffect(() => {})
// ...当该侦听器不再需要时
unwatch()
```



### 生命周期使用

```
<script setup>
import { onMounted } from 'vue'

onMounted(() => {
  console.log(`the component is now mounted.`)
})
</script>
```



### props  

```vue

<script setup>
    //  defineProps里面声名props会有哪些值，例如父组件传给子组件一个'num'值
    const props = defineProps(['num'])
    // 在script里使用props的值要带'props.'',在template中直接 {{num}} 就可以获取
    console.log(props.num)
</script>

// 对象式声明props，只是写法不同
defineProps({
  title: String,
  likes: Number
})
```

### emit

```
// 父组件 app.vue
<template>
	<son @sonClick="getSon" @sonClick2="getSon2(num)"></son>
</template>
<script setup>
    const getSon=()=>{}
    const getSon2=(num)=>{}
</script>

//子组件  son.vue

 //  defineEmits里面声名 自定义事件  
const emit = defineEmits(['sonClick','sonClick2'])
// emit触发事件，可携带参数
emit('sonClick')
emit('sonClick2','123')

```

### 父组件通过ref调用子组件

```vue
父组件  app.vue
<chuanzhi ref="myson" ></chuanzhi>
<button @click="mySonRef">{{myson}}</button>

<script setup>
//  定义一个和子组件同名的ref变量
let myson=ref()
const mySonRef=()=>{
  // 通过myson.value获取子组件的属性，但只有子组件暴露出来的才能访问
  console.log('myson',myson.value)
  myson.value.ceshi()
}
</script>

子组件  chuanzhi.vue
<script setup>
let sons=ref('123')
const ceshi=()=>{
    console.log('123')
}
// 子组件通过defineExpose向外暴露属性和方法，父组件才能访问
defineExpose({
  sons,ceshi
})
</script>
</script>


```

### nextTick

 若要等待一个状态改变后的 DOM 更新完成 ,可以使用nextTick

```
import { nextTick } from 'vue'

nextTick(() => {
    // 访问更新后的 DOM
  })
```

### 依赖注入

依赖提供方：provide

```
<script setup>
import { provide } from 'vue'

provide(/* 注入名 */ 'message', /* 值 */ 'hello!')

// 第二个参数是提供的值，值可以是任意类型，包括响应式的状态，比如一个 ref
const count = ref(0)
provide('key', count)
</script>
```

注入：inject  接收依赖

```
<script setup>
import { inject } from 'vue'

const message = inject('message')

// 如果没有祖先组件提供 "message"， `value` 会是 "这是默认值"
const value = inject('message', '这是默认值')

</script>
```

## 点击侧边展示导航的组件  

用的ant-design-vue的 a-drawer

```vue
<template>
  <div>
    <div @click="showBannel" class="go-back"><a-icon type="menu-fold" /></div>
    <a-drawer
      class="drawer"
      title="导航菜单"
      :placement="placement"
      :closable="false"
      :visible="visible"
      @close="onClose"
    >
      <div class="company-tab">
        <div class="tab" :class="path=='/zph/recruitactivity'?'active':''" @click="goIndex"><a-icon type="appstore" class="icon"/>职位信息</div>
        <div class="tab" :class="path=='/zph/index'?'active':''" @click="goJobIndex"><a-icon type="book" class="icon" />企业名录</div>
        <div class="tab" :class="path=='/zph/policy'?'active':''" @click="$router.push('/zph/policy')" ><a-icon type="bank" class="icon"/>人才政策</div>
        <!-- <div class="tab" @click="openUrl('https://wx.vzan.com/live/tvchat-407596622?v=638007674965505737')"><a-icon type="camera" class="icon"/>活动直播</div>
        <div class="tab" @click="openUrl('http://www.sdbys.com/sdbysadv/qyxj/index.html')"><a-icon type="filter" class="icon"/>企业宣讲</div> -->
      </div>
    </a-drawer>
  </div>
</template>

<script>
export default {
  data () {
    return {
        placement: 'left',
        visible: false,
        style: 'border-color: #167cf3;color: #167cf3;',
        path: ''
    }
  },
  methods: {
    goBack () {
        this.$router.go(-1)
    },
    showBannel () {
        this.visible = !this.visible
    },
    onClose () {
        this.visible = false
    },
    openUrl (item) {
      if (item) {
        window.open(item, "_blank")
      }
    },
        // 点击热门企业查看更多，跳转到企业网申界面
    goJobIndex () {
      this.$router.push({
        path: "/zph/index",
        query: { fairId: "866a410198364c9b8f51f6abb91ef001" }
      })
    },
    goIndex () {
        this.$router.push({
        path: "/zph/recruitactivity"
      })
    }
  },
  created () {

  },
  mounted () {
    this.path = this.$route.path
  }
}
</script>
<style scoped >
 .go-back{
    position: fixed;
    background-color: #FFF;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    box-shadow: 0 0 6px rgb(0 0 0 / 12%);
    cursor: pointer;
    z-index: 1000;
    top:10px;
    right:10px
 }

.company-tab {
        margin: 0 auto;
        background:#001529;
        padding-left: 0;

      }
.tab{
    display: flex;
    align-items: center;
    padding-left:30px;
    margin:10px 0;
    color:white;
    background: #001529;
    width:100%;
    height:40px;
    margin-bottom: 2px;
    font-size: 14px;
    cursor: pointer;
}
.tab.active {
    background: #167cf3;
    /* background: rgba(0, 0, 0, 0.04); */
}
.icon{
    margin-right:10px
}
>>>.ant-drawer-body {
    padding:0
}
>>>.ant-drawer-wrapper-body {
    background:#001529;
}
>>>.ant-drawer-header {
   background:#001529;
   color:white;
   font-weight: 600;
}
>>>.ant-drawer-title {
    color:white
}
</style>

```

##  树形结构插件 vue2-org-tree(组织结构图)

 [Vue 树形结构插件 vue2-org-tree - 掘金 (juejin.cn)](https://juejin.cn/post/7011705093665849375) 

 [详解树状结构图 vue-org-tree - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/117300250) 