---
# icon: edit
date: 2022-01-03
category:
  - javascript
tag:
  -javascript
---

# javaScript

## 打开url

可以使用a链接  location.href=url   或者  window.open(url)

当在新页面中打开时，可以使用  window.open(url，”_blank“)

（遇到过问题）在vue项目中，后台返回一个类如  ”www.aaaaa.com“  的 url 时，此时使用  window.open(url，”_blank“)  ,发现网页跳转到  http://localhost:8080/abc/www.aaaaa.com 这样的地址，url作为路径加在了网址后面，明显有错，路径不正常。

（解决方法）window.open("http://" + url, "_blank")  将**协议名**作为字符串和url进行拼接，或者让后端将网址的协议名都加上，此时就能跳转正常了。

## js中日期格式化常用方法

 [js中日期格式化常用方法 - 掘金 (juejin.cn)](https://juejin.cn/post/6999283812958109709) 

 [(207条消息) JS：格式化时间的方法，及获取指定格式的方法_js获取固定格式_前端-如此如此。的博客-CSDN博客](https://blog.csdn.net/weixin_44136505/article/details/120549478) 

moment.js 与 day.js 日期库（推荐使用day.js）



## js代码技巧

 [21 个简单实用的 JavaScript 代码技巧 (qq.com)](https://mp.weixin.qq.com/s/Ubk7qcbN5VS52Mtb2yeYpg) 

## JS在web页面中调起本地应用程序

 [(210条消息) JS在web页面中调起本地应用程序_js启动本地程序_nine_three_的博客-CSDN博客](https://blog.csdn.net/nine_three_/article/details/121146847) 

（注意：调用微信时，文件导出的文件名 weixin ）

## 脚手架教程

 [写给5年前端妹子的三万字脚手架教程 - 掘金 (juejin.cn)](https://juejin.cn/post/7260144602471776311#heading-26) 

## js判断url是否是合法http/https

https://blog.csdn.net/qq_44275213/article/details/110527407



## websocket

参考文章： [认识WebSocket并搭建服务端_websocket服务器端搭建_Hacah的博客-CSDN博客](https://blog.csdn.net/hwh295/article/details/123554646) 

参考视频： [【知识点】websocket2_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HX4y1L7GK/?p=2&spm_id_from=pageDriver&vd_source=f25f5a8d75a3a60d5a288f726803ec11) 

请求的network详情参考： [HTML5 WebSocket | 菜鸟教程 (runoob.com)](https://www.runoob.com/html/html5-websocket.html) 

1.新建 WebSocket 实例

```javascript
var ws = new WebSocket('ws://localhost:3000');
```

2.webSocket.readyState

`readyState`属性返回实例对象的当前状态，共有四种。

- CONNECTING：值为0，表示正在连接。
- OPEN：值为1，表示连接成功，可以通信了。
- CLOSING：值为2，表示连接正在关闭。
- CLOSED：值为3，表示连接已经关闭，或者打开连接失败。

3.webSocket.onopen

`onopen`属性，用于指定连接成功后的回调函数。

4.webSocket.onclose

`onclose`属性，用于指定连接关闭后的回调函数。

5.webSocket.onmessage

`onmessage`属性，用于指定收到服务器数据后的回调函数。

6.webSocket.send()

`send()`方法用于向服务器发送数据。

7.webSocket.bufferedAmount

`bufferedAmount`属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。

8.webSocket.onerror

`onerror`属性，用于指定报错时的回调函数。

### 实践

websocket.js   （npm i express     npm install ws） npm i cors -S (解决跨域)

node在package.json添加 "type": "module" 可以使用 import 语法，否则报错

```js
import express from 'express'
import http from 'http'
import {WebSocketServer} from 'ws'


const app=express()
const server=http.createServer(app) //创建一个http服务

const wss=new WebSocketServer({server})
wss.on('connection',(ws)=>{
    console.log("connection open")
    // 给客户端发消息
    ws.send('hell0 client')

    ws.onmessage=function(e){
        console.log('客户端发送的数据'+e.data)
    }
})

server.listen(3000)
```

socket.html     

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const ws = new WebSocket('ws://localhost:3000');
        ws.onopen=function(){
            console.log("open")
            ws.send("server open")  //给服务端发送消息
        }
        // 监控服务端数据
        ws.onmessage=function(e){
            console.log('服务端响应的数据'+e.data)
        }

    </script>
</body>
</html>
```

## JS如何实现下拉刷新和上拉加载!

[javascript - 面试官：JS如何实现下拉刷新和上拉加载! - JS每日一题 - SegmentFault 思否](https://segmentfault.com/a/1190000039693056)

### ai答案

PC端的下拉加载通常是通过监听滚动事件，判断滚动位置是否到达底部，然后触发加载新内容的操作。以下是一个简单的示例代码：

HTML部分：

```html
<div id="content">
  <!-- 已加载的内容 -->
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
  <!-- 加载更多的内容会被追加到这里 -->
</div>
```

CSS部分：

```css
#content {
  height: 300px; /* 设置内容区域的高度 */
  overflow-y: scroll; /* 显示滚动条 */
}

.item {
  height: 100px;
  background-color: #f0f0f0;
  margin-bottom: 10px;
}
```

JavaScript部分：

```javascript
var content = document.getElementById('content');

content.addEventListener('scroll', function() {
  // 判断滚动位置是否到达底部
  if (content.scrollTop + content.clientHeight >= content.scrollHeight) {
    // 加载新内容
    loadMoreContent();
  }
});

function loadMoreContent() {
  // 模拟异步加载
  setTimeout(function() {
    // 创建新内容
    var newItem = document.createElement('div');
    newItem.className = 'item';
    newItem.innerText = 'New Item';

    // 将新内容追加到内容区域
    content.appendChild(newItem);
  }, 1000);
}
```

上述代码中，通过监听`scroll`事件，当滚动位置到达底部时，调用`loadMoreContent`函数加载新内容。`loadMoreContent`函数模拟异步加载新内容，并将新内容追加到内容区域中。

注意：该示例代码仅提供一种实现方式，具体实现可能会根据具体需求进行调整。

## [通过一个onclick实现点击时不同的效果](https://www.cnblogs.com/Hlong-ZY/articles/7144560.html)

以下实现两次鼠标进入图片时，展示不同的效果

```html
<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
<style>
/* 图片过渡效果样式 */
 img {
 width: 300px;
 height: 300px;
transition: all 0.5s ease-in-out;
}
 </style>
</head>

<body>
<div style="width: 300px;height: 300px;background-color: red;">
<img id="img" onmouseenter="mouseEnter()" src="https://pic.ntimg.cn/file/20200605/23605973_173021196899_2.jpg" alt="">
 </div>

 <script>
    var img = document.getElementById('img');
    function mouseEnter(){
       img.style.width="50%";
       img.style.height="50%";
       img.style.marginTop="50%";
       img.style.marginLeft="50%";
       img.onmouseenter=mouseEnterAgain;
    }
    function mouseEnterAgain (){
        img.style.width="100%";
       img.style.height="100%";
       img.style.marginTop="0px";
       img.style.marginLeft="0px";
       //返回第一次执行的函数，实现循环执行
        img.onmouseenter = mouseEnter;    
    }
 </script>

</body>

</html>
```

