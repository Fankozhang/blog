---
icon: edit
date: 2022-01-06
category:
  - node
tag:
  - node
  - javascript
star: 10
---

# Node

## 学习node,express，koa

看视频  [项目实战-Node+Koa2从零搭建通用API服务](https://www.bilibili.com/video/BV13A411w79h/?p=1&vd_source=f25f5a8d75a3a60d5a288f726803ec11) ，作者写的源码和地址  [jj112358/node-api: 【杰哥课堂】-项目实战-通用api接口服务 (github.com)](https://github.com/jj112358/node-api)     

我跟着写了一点代码，放到码云上了，[my-node-koa: 学习node 和 koa 框架的记录（我的码云仓库，代码内容应该不全，还没全部看完）)](https://gitee.com/fankozhang/my-node) 



 [Express 中文文档 - Express 中文文档 (nodejs.cn)](https://nodejs.cn/express/) 

 [Express/Node 入门 - 学习 Web 开发 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/Introduction) 

## node+express创建使用

### 项目初始化

`pnpm init`

### 下载express依赖

`pnpm install express`

### 根目录创建  app.js

```
const express = require('express')
const app = express()

const port = 3000

app.get('/', (req, res) => {
    res.send('Hello World yes!')
})

app.listen(port, () => {
    console.log(`server running at http://127.0.0.1:${port}`)
})
```

### 安装和访问MySQL

`pnpm install mysql`

```
// 导入MySQL
const mysql = require('mysql')
    // 创建连接
const db = mysql.createConnection({
        host: '127.0.0.1',
        user: 'root',
        password: '13456',
        database: 'vue3_node_bookmanage'
    })

//  请求数据库
app.get('/get', (req, res) => {
    let sql = 'select * from book'
    if (req.query.bookName) {
        sql = `SELECT * FROM book WHERE book_name like '%${req.query.bookName}%'`
    }

    db.query(sql, (err, result) => {
        if (err) throw err
        // 返回结果
        res.send(result)
    });
})
```

### 获取客户端发送过来的查询参数

```
//  get 请求
通过req.query可以获取到客户端发送过来的查询参数
    app.get('/',(req,res)=>{
      // 注意：默认情况下，req.query是一个空对象{}
      console.log(req.query);   //{}
      res.send(req.query)
    })
    
通过req.params可以动态匹配参数
    // 这里的:id是一个动态的参数
    app.get('/user/:id',(req,res)=>{
      // req.params是动态匹配的URL参数，默认也是一个空对象
      console.log(req.params);
      res.send(req.params)
    })
    
也可以传两个参数(甚至更多)
    app.get('/user/:id/:name',(req,res)=>{
      res.send(req.params)
    })
    
    
//  post请求
解析前端请求的请求体数据  x-www-form
app.use(express.urlencoded({ extended: false }));  // 解析x-www-form类型的请求
解析前端请求的请求体数据  json
app.use(express.json());  // 解析json类型的请求

//  用 req.body 来获取请求体
router.post('/test', function(req, res, next) {
    console.log(req.body)
    res.json(req.body)
})
```



### 下载body-parser（用于参数解析）

`pnpm i body-parser`

app.js加入

```
//加入body-parser  (由于参数解析)
let bodyParser = require('body-parser')
const app = express()
    //解析应用程序/x-ww-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))
    //解析application/json
app.use(bodyParser.json())
```

### 前端访问增加跨域设置

```
proxy: {
            "/api": {
                target: "http://127.0.0.1:3000",
                changeOrigin: true,
                rewrite: (path) => path.replace(/^\/api/, '')
            }
        }
```

### express生成器

```
npm install -g express-generator

以下创建一个名为 myapp 的 Express 应用程序。该应用程序将在当前工作目录中名为 myapp 的文件夹中创建，并且视图引擎将设置为 Pug

express --help  //查看帮助命令

express --view=pug myapp  //  --view选择视图（模板）引擎  此处使用pug(推荐)项目创建完成后跟着终端提示进行下一步即可，也可使用 ejs 等引擎

cd myapp
npm install
set DEBUG=myapp:* & npm start


```

### 静态文件

```
 存放静态文件使用express.static(root, [options])
 
 //  使用以下代码在名为 public 的目录中提供图像、CSS 文件和 JavaScript 文件
 // public目录建立在根目录下，  例如文件路径为：public/images/dot.png
 app.use(express.static('public')) 
 http://127.0.0.1:3002/images/dot.png  // 这个地址可访问到静态文件
 
 //要使用多个静态资产目录，请多次调用 express.static 中间件函数：
 app.use(express.static('public'))
app.use(express.static('files'))

//为 express.static 函数服务的文件创建虚拟路径前缀（该路径实际上并不存在于文件系统中），指定挂载路径为静态目录
// public目录建立在根目录下，  例如文件路径为：public/images/dot.png,如下的‘/static’是创建的虚拟路径
app.use('/static', express.static('public'))
http://127.0.0.1:3002/static/images/dot.png  // 这个地址可访问到静态文件

```

### 中间件函数

```
//  中间件函数定义如下  （第三个函数next,调用此函数会调用应用程序中的下一个中间件函数。）
//  中间件函数在发出请求之前执行，通过调用next方法，进入下一个中间件执行，所以next（）不能少
const myLogger = function (req, res, next) {
  console.log('LOGGED')
  next()
}

app.use(myLogger)

app.get('/', (req, res) => {
  res.send('Hello World!')
})

// 此时请求 '/' 时，控制台会打印 LOGGED

1.应用级中间件：使用 app.use() 和 app.METHOD() 函数将应用级中间件绑定到 app 对象 的实例

要跳过路由中间件堆栈中的其余中间件函数，请调用 next('route') 将控制权传递给下一个路由。注意：next('route') 仅适用于使用 app.METHOD() 或 router.METHOD() 函数加载的中间件函数。

//当有多个中间件时，可以将多个中间件放在一个数组中。
//  设logOriginalUrl，logMethod 为两个中间件
const logStuff = [logOriginalUrl, logMethod]
app.get('/user/:id', logStuff, (req, res, next) => {
  res.send('User Info')
})

2.路由级中间件
路由级中间件的工作方式与应用级中间件相同，只是它绑定到 express.Router() 的实例。
使用 router.use() 和 router.METHOD() 函数加载路由级中间件。

此示例显示了一个处理对 /user/:id 路径的 GET 请求的中间件子堆栈。
    const express = require('express')
    const app = express()
    const router = express.Router()

    // predicate the router with a check and bail out when needed
    router.use((req, res, next) => {
      if (!req.headers['x-auth']) return next('router')
      next()
    })

    router.get('/user/:id', (req, res) => {
      res.send('hello, user!')
    })

    // use the router and 401 anything falling through
    app.use('/admin', router, (req, res) => {
      res.sendStatus(401)
    })
    
    
3.错误处理中间件
错误处理中间件总是需要四个参数。您必须提供四个参数以将其标识为错误处理中间件函数。即使您不需要使用 next 对象，您也必须指定它来维护签名。否则，next 对象将被解释为常规中间件，无法处理错误。

    app.use((err, req, res, next) => {
      console.error(err.stack)
      res.status(500).send('Something broke!')
    })

4.内置中间件
中间件列表查看   https://github.com/senchalabs/connect#middleware
express.static 提供静态资源，例如 HTML 文件、图像等。
express.json 使用 JSON 有效负载解析传入请求。注意：可用于 Express 4.16.0+
express.urlencoded 使用 URL 编码的负载解析传入的请求。注意：可用于 Express 4.16.0+

5.第三方中间件
以下示例说明了安装和加载 cookie 解析中间件函数 cookie-parser。
    npm install cookie-parser

    const cookieParser = require('cookie-parser')
    // load the cookie-parsing middleware
    app.use(cookieParser())
```

